<!DOCTYPE html><html lang="en-us"><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>What DevOps Already Knew About AI Development - Chip Blogs Things</title><meta name="description" content="AI won’t fix your bottlenecks. It just hits them faster. Gene Kim’s five stages still define software delivery in the age of agentic coding."><meta name="generator" content="Publii Open-Source CMS for Static Site"><link rel="canonical" href="https://blog.chipjohnson.net/what-devops-already-knew-about-ai-development.html"><link rel="alternate" type="application/atom+xml" href="https://blog.chipjohnson.net/feed.xml" title="Chip Blogs Things - RSS"><link rel="alternate" type="application/json" href="https://blog.chipjohnson.net/feed.json" title="Chip Blogs Things - JSON"><meta property="og:title" content="What DevOps Already Knew About AI Development"><meta property="og:image" content="https://blog.chipjohnson.net/media/posts/9/Screenshot-2026-02-24-at-11.26.06-AM.png"><meta property="og:image:width" content="2040"><meta property="og:image:height" content="1156"><meta property="og:site_name" content="Chip Blogs Things"><meta property="og:description" content="AI won’t fix your bottlenecks. It just hits them faster. Gene Kim’s five stages still define software delivery in the age of agentic coding."><meta property="og:url" content="https://blog.chipjohnson.net/what-devops-already-knew-about-ai-development.html"><meta property="og:type" content="article"><meta name="twitter:card" content="summary"><meta name="twitter:site" content="@JefrsonStarChip"><meta name="twitter:title" content="What DevOps Already Knew About AI Development"><meta name="twitter:description" content="AI won’t fix your bottlenecks. It just hits them faster. Gene Kim’s five stages still define software delivery in the age of agentic coding."><meta name="twitter:image" content="https://blog.chipjohnson.net/media/posts/9/Screenshot-2026-02-24-at-11.26.06-AM.png"><link rel="stylesheet" href="https://blog.chipjohnson.net/assets/css/style.css?v=ad994e06fe4ccf9aa9bbf0f25d02eaf2"><script type="application/ld+json">{"@context":"http://schema.org","@type":"Article","mainEntityOfPage":{"@type":"WebPage","@id":"https://blog.chipjohnson.net/what-devops-already-knew-about-ai-development.html"},"headline":"What DevOps Already Knew About AI Development","datePublished":"2026-02-24T11:24-07:00","dateModified":"2026-02-24T14:10-07:00","image":{"@type":"ImageObject","url":"https://blog.chipjohnson.net/media/posts/9/Screenshot-2026-02-24-at-11.26.06-AM.png","height":1156,"width":2040},"description":"AI won’t fix your bottlenecks. It just hits them faster. Gene Kim’s five stages still define software delivery in the age of agentic coding.","author":{"@type":"Person","name":"Chip Johnson","url":"https://blog.chipjohnson.net/authors/chip-johnson/"},"publisher":{"@type":"Organization","name":"Chip Johnson"}}</script><script async src="https://www.googletagmanager.com/gtag/js?id=G-GGVEEMWCMW"></script><script>window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-GGVEEMWCMW');</script></head><body><div class="site-container"><header class="top" id="js-header"><a class="logo" href="https://blog.chipjohnson.net/">Chip Blogs Things</a></header><main><article class="post"><div class="hero"><figure class="hero__image hero__image--overlay"><img src="https://blog.chipjohnson.net/media/posts/9/Screenshot-2026-02-24-at-11.26.06-AM.png" srcset="https://blog.chipjohnson.net/media/posts/9/responsive/Screenshot-2026-02-24-at-11.26.06-AM-xs.webp 300w, https://blog.chipjohnson.net/media/posts/9/responsive/Screenshot-2026-02-24-at-11.26.06-AM-sm.webp 480w, https://blog.chipjohnson.net/media/posts/9/responsive/Screenshot-2026-02-24-at-11.26.06-AM-md.webp 768w, https://blog.chipjohnson.net/media/posts/9/responsive/Screenshot-2026-02-24-at-11.26.06-AM-lg.webp 1024w, https://blog.chipjohnson.net/media/posts/9/responsive/Screenshot-2026-02-24-at-11.26.06-AM-xl.webp 1360w, https://blog.chipjohnson.net/media/posts/9/responsive/Screenshot-2026-02-24-at-11.26.06-AM-2xl.webp 1600w" sizes="(max-width: 1600px) 100vw, 1600px" loading="eager" height="1156" width="2040" alt="Gene Kim (Left) &amp; John Willis on stage at a conference"><figcaption>Gene Kim &amp; Johnn Willis</figcaption></figure><header class="hero__content"><div class="wrapper"><div class="post__meta"><time datetime="2026-02-24T11:24">February 24, 2026</time></div><h1>What DevOps Already Knew About AI Development</h1><div class="post__meta post__meta--author"><a href="https://blog.chipjohnson.net/authors/chip-johnson/" class="feed__author">Chip Johnson</a></div></div></header></div><div class="wrapper post__entry"><p>In 2018, Gene Kim and John Willis released <a href="https://itrevolution.com/product/beyond-the-phoenix-project/" title="IT Revolution Press" target="_blank"><i>Beyond the Phoenix Project</i></a>, a nine-part audio series that digs into the philosophical roots of the DevOps movement. It's an excellent supplement to <a href="https://itrevolution.com/product/the-phoenix-project/" title="IT Revolution Press" target="_blank"><i>The Phoenix Project</i></a>. Where the novel shows the pain, the audio series explains why it hurts. But because it’s an audio companion piece, most people have never heard it.</p><p>The part that’s most stuck with me over the years is what Kim calls “the five predictable bottlenecks of software delivery.” They’re numbered 1-5, and you must solve them in order. No skipping ahead. They go like this:</p><figure class="post__image post__image--center"><img loading="lazy" src="https://blog.chipjohnson.net/media/posts/9/bottlenecks.png" height="1000" width="1238" alt="1. Environment Creation.  2. Code Deployment.  3. Tessting.  4. Architecure.  5. Ideas. You want to be at 5." sizes="100vw" srcset="https://blog.chipjohnson.net/media/posts/9/responsive/bottlenecks-xs.webp 300w, https://blog.chipjohnson.net/media/posts/9/responsive/bottlenecks-sm.webp 480w, https://blog.chipjohnson.net/media/posts/9/responsive/bottlenecks-md.webp 768w, https://blog.chipjohnson.net/media/posts/9/responsive/bottlenecks-lg.webp 1024w, https://blog.chipjohnson.net/media/posts/9/responsive/bottlenecks-xl.webp 1360w, https://blog.chipjohnson.net/media/posts/9/responsive/bottlenecks-2xl.webp 1600w"><figcaption>The Five Predictable Bottlenecks of Software Delivery, by Gene Kim.</figcaption></figure><p>AI development doesn't eliminate these bottlenecks. It just slams you into the next one faster. Face-first.</p><p>Over the last few years, every time I've presented at a tech conference, I've included a slide on the bottlenecks. I always tell people, "If you're going to take a picture of one slide from this presentation, make it this one." It's the single most useful mental model I've found for diagnosing why a software organization is slow.<br></p><h2 id="the-bottlenecks-explained">The Bottlenecks Explained</h2><h2 id="environments">Environments</h2><p>At the first bottleneck, your teams are stuck waiting for environments. Somebody has to provision the infrastructure, configure DNS, file a ticket to open the firewall, and wait. The fix to this is on-demand environment creation: press the button, get a runtime, whether dev, staging, or prod. Automate creation. Make new ones all the time, throw away the old ones. Make it self-service. Move on.</p><h2 id="deployment">Deployment</h2><p>Next is deployment. Once you can create environments, you’ll likely realize pushing code to them is its own nightmare. Too many steps, too many handoffs, too many pieces to coordinate. Kim emphasizes that teams should build their deployments as a single-piece flow.<br></p><p>In a factory, batch production means you make 500 units of part A, then 500 units of part B, then assemble them all at once. But batches hide defects and slow the line to the speed of the worst delay; a flaw replicated 500 times takes longer to unwind. By contrast, single-piece flow means one unit moves through every station before the next unit starts. You catch problems immediately. Nothing queues. The system moves continuously, and defects are caught and resolved quickly.<br></p><p>In software, the equivalent is one change, one deploy. Not ten features bundled into a release train, or a quarterly mega-release window. One commit moves through build, test, and deploy before you start the next. It does so in seconds. The goal is to make deployments so routine that they disappear from thought entirely.<br></p><p>Developers have traditionally resisted single-piece flow, not because they lack discipline, but because the system has historically punished it. When deploys take 45 minutes, and a failed build might page you at 2 AM, batching is rational. It’s not laziness; you’re amortizing risk and overhead. Batching is what happens when tool use is expensive and failure is loud. Developers learned to do it because the system demanded it.<br></p><p>Claude Code doesn’t have that instinct because it never paid those costs. When Superpowers manages implementation, it breaks work into tightly scoped tasks. Dependent tasks run sequentially. Independent tasks run in parallel, each in its own worktree. Either way, each task is a single piece moving through implementation, test, and review before completion. When parallel tasks finish, Claude reconciles the work and handles the merge. It is not batching. It is multiple single-piece flows running at once.<br></p><p>On the web, each session runs in its own sandboxed environment, isolated by design. Same principle. Different mechanism.<br></p><h2 id="testing">Testing</h2><p>You're deploying fast, but you're shipping bugs faster. Every change surface needs a test. You need confidence that what you shipped actually works. They need to be the right tests, and they need to be fast.</p><h2 id="architecture">Architecture</h2><p>Congratulations! You've got tests, fast deploys, and on-demand runtimes for every work context. Now the codebase itself is the problem. Tech debt accumulates. Components become so tightly coupled that changing one thing breaks three others. You need to pay this all down regularly and keep things loosely coupled enough so the system can evolve.</p><h2 id="ideas">Ideas</h2><p>Here is where Kim says the bottleneck should be. When environments spin up on demand, deployments are trivial, tests are fast and comprehensive, and architecture is clean, the limiting factor becomes how fast humans can come up with good things to build. The speed of ingenuity.<br></p><p>That’s where you want to live, all the time.<br></p><p>It was a radical statement in 2018. For a lot of organizations, it still is today.</p><hr class="separator separator--dots"><h2 id="this-all-still-applies-to-your-agentic-coding-projects">This All Still Applies to Your Agentic Coding Projects</h2><p>As I’ve been getting comfortable using Claude Code on the web, connected directly to my GitHub repos, I keep coming back to Kim's framework. It maps perfectly to how agentic development projects succeed.</p><p>The bottlenecks are the same. The order is the same. And if you don't address them, you'll stall in the same places, no matter how advanced the model writing your code.</p><h2 id="environment-creation">Environment Creation</h2><p>Claude Code on the web can see your repo and push branches. But if you can’t actually see what it builds, you’ve got a bottleneck. The goal is a preview environment for every PR.</p><p>For frontend projects, tools like <a href="https://vite.dev/" title="Vite" target="_blank">Vite</a> paired with <a href="https://www.netlify.com/" title="Netlify" target="_blank">Netlify</a> or <a href="https://vercel.com/" title="Vercel" target="_blank">Vercel</a> give you this almost for free. Every pull request gets a deploy preview with a clickable URL. For infrastructure-heavy projects, <a href="https://developer.hashicorp.com/terraform" title="Terraform" target="_blank">Terraform</a> with <a href="https://github.com/features/actions" title="GitHub Action" target="_blank">GitHub Actions</a> can spin up ephemeral staging environments on demand, scoped to the branch and torn down when the PR closes.<br></p><p>The specifics depend on your stack, but the principle doesn’t. Regardless of how you run your coding agent, when it finishes a task and pushes a branch, you should be able to see the result running somewhere real, with a full copy of the stack, and full resource isolation. If that’s not the case, fix that first. Everything downstream depends on it.</p><h2 id="code-deployment">Code Deployment</h2><p>Once your preview environments exist, the question becomes, how does code get there? The answer should be the same code pipeline that deploys to production. Same mechanism, same gates, every time. A push to a branch triggers a preview. A merge to main triggers staging. A tagged release triggers production. The same code deploys it all, the only difference is the target.<br></p><p>Claude Code on the web already pushes branches to remote when it finishes a task. Meet it halfway. Make sure your pipeline picks up from there without human intervention.</p><p>GitHub Actions makes this straightforward. Define workflow triggers that match each stage: a push to any PR branch deploys a preview. a merge to main deploys to staging. A release tag deploys to production. Three workflows, same deployment logic, different targets. The pipeline definition lives in the repo alongside the code, so Claude can see it, understand it, and even modify it as the project evolves.</p><p>Here’s the catch: Because agents don’t batch, it’s common to have parallel tasks finishing within minutes, each opening a pull request, each triggering a preview environment. A pipeline that might have worked fine for a team of humans deploying a few times a day might buckle under an agent that treats deployment as a function call. Integration environments like staging will still serialize by design, but the concurrency pressure shows up earlier, in previews and development targets.</p><p>Your deployment pipeline will need to support concurrent builds without shared state between resources. If your automation can’t handle multiple simultaneous pushes to dev environments without choking, that’s the bottleneck.</p><h2 id="testing">Testing</h2><p>As I wrote in <a href="https://blog.chipjohnson.net/clarity-is-the-new-bottleneck.html" target="_blank">my last post</a>, Jesse Vincent's <a href="https://github.com/obra/superpowers" title="Superpowers" target="_blank">Superpowers</a> plugin enforces real red-green-refactor test-driven development. Every change gets an executable definition of success before implementation starts.</p><p>Even with TDD enforced, though, agents will happily generate code with test coverage that looks comprehensive but tests implementation rather than observable behavior. The tests pass because the agent wrote them to pass, not because they validate anything a user would care about.</p><p>But now that you’ve built proper preview environments, you can go further. Run <a href="https://playwright.dev/" title="Playwright" target="_blank">Playwright</a> tests against a real deployment. Exercise actual infrastructure with integration tests. Your agent can help write these tests and handle the syntax, but you still have to specify what “working” means.</p><p>More than any other part of an agent-authored pull request, inspect the tests. Make sure they’re testing something that matters. You decide what’s meaningful, the agent writes the tests, and your CI infrastructure runs them.</p><h2 id="architecture">Architecture</h2><p>Here's where agentic coding colliding with DevOps philosophy gets interesting and dangerous.</p><p>Claude is remarkably tolerant of tight coupling. It will eat the maintenance pain of tangled dependencies far longer than any human team would. Rename a data model and watch it calmly rewrite half the repo without complaint. It doesn't miss a capitalization in camelCase. It just quietly absorbs the complexity.</p><p>This is a genuine advantage. It means you can move fast on projects where the architecture isn't ideal, because the carrying cost of that mess is temporarily subsidized by an agent that can’t get frustrated.</p><p><i>It is also a trap.</i></p><p>Tight coupling that an AI can tolerate is still tight coupling. The moment you need to hand the codebase to a human for review, audit, or onboarding, the accumulated architectural debt lands all at once. And because Claude never complained, you might not realize how bad it’s become.</p><p>Use Superpowers’ <a href="https://github.com/obra/superpowers/blob/main/skills/requesting-code-review/SKILL.md" title="GitHub" target="_blank">requesting-code-review</a> skill regularly. Ask Claude to explain why it touched files that seem unrelated to the task. If the answer is "because everything is connected to everything," that's your signal. Pay the debt while you can still afford it.</p><h2 id="the-speed-of-ideas">The Speed of Ideas</h2><p>If you’ve solved environments, deployment, testing, and architecture, you’re here. This is where you want to be.</p><p>Two weeks ago, I took my niece to see <i>Avatar 3</i> and had a good thought about a project while waiting for the previews to start. Because I had Claude Code on the web connected to the repo and GitHub Actions handling the pipeline, I was able to take out my phone, type a prompt, and kick off work while I sat and shared a movie with a loved one. When the credits rolled I was able to review the PR, see working code, merge, and push to production before we got back to the car.</p><p>That’s when it all clicked into place. The bottleneck wasn’t tooling, infrastructure, or process. It was whether I had something worth building next. It didn’t matter if I was in a movie theater, at my desk kicking off three parallel sessions, or sitting on a plane with nothing but a browser tab.</p><p>The bottleneck is no longer provisioning, deploying, testing, or untangling. It’s you. How fast can you articulate what “done” looks like? How precisely can you define success? How many good ideas can you feed the system before lunch?</p><p>Kim said this is where the bottleneck should be. Now it’s on you.<br></p></div><footer class="wrapper post__footer"><p class="post__last-updated">This article was updated on February 24, 2026</p><ul class="post__tag"><li><a href="https://blog.chipjohnson.net/tags/claude/">Claude</a></li><li><a href="https://blog.chipjohnson.net/tags/claude-code/">Claude Code</a></li><li><a href="https://blog.chipjohnson.net/tags/cloud/">Cloud</a></li><li><a href="https://blog.chipjohnson.net/tags/devops/">DevOps</a></li><li><a href="https://blog.chipjohnson.net/tags/github/">GitHub</a></li><li><a href="https://blog.chipjohnson.net/tags/playwright/">Playwright</a></li><li><a href="https://blog.chipjohnson.net/tags/product-management/">Product Management</a></li><li><a href="https://blog.chipjohnson.net/tags/terraform/">Terraform</a></li></ul><div class="post__share"><a href="https://www.facebook.com/sharer/sharer.php?u=https%3A%2F%2Fblog.chipjohnson.net%2Fwhat-devops-already-knew-about-ai-development.html" class="js-share facebook" rel="nofollow noopener noreferrer"><svg class="icon" aria-hidden="true" focusable="false"><use xlink:href="https://blog.chipjohnson.net/assets/svg/svg-map.svg#facebook"/></svg> <span>Facebook</span> </a><a href="https://twitter.com/share?url=https%3A%2F%2Fblog.chipjohnson.net%2Fwhat-devops-already-knew-about-ai-development.html&amp;via=%40JefrsonStarChip&amp;text=What%20DevOps%20Already%20Knew%20About%20AI%20Development" class="js-share twitter" rel="nofollow noopener noreferrer"><svg class="icon" aria-hidden="true" focusable="false"><use xlink:href="https://blog.chipjohnson.net/assets/svg/svg-map.svg#twitter"/></svg> <span>Twitter</span> </a><a href="https://www.linkedin.com/sharing/share-offsite/?url=https%3A%2F%2Fblog.chipjohnson.net%2Fwhat-devops-already-knew-about-ai-development.html" class="js-share linkedin" rel="nofollow noopener noreferrer"><svg class="icon" aria-hidden="true" focusable="false"><use xlink:href="https://blog.chipjohnson.net/assets/svg/svg-map.svg#linkedin"/></svg> <span>LinkedIn</span></a></div><div class="post__bio bio"><div class="bio__info"><h3 class="bio__name"><a href="https://blog.chipjohnson.net/authors/chip-johnson/" rel="author">Chip Johnson</a></h3></div></div></footer></article><nav class="post__nav"><div class="post__nav-inner"><div class="post__nav-prev"><svg width="1.041em" height="0.416em" aria-hidden="true"><use xlink:href="https://blog.chipjohnson.net/assets/svg/svg-map.svg#arrow-prev"/></svg> <a href="https://blog.chipjohnson.net/clarity-is-the-new-bottleneck.html" class="post__nav-link" rel="prev"><span>Previous</span> Clarity Is the New Bottleneck</a></div></div></nav><div class="post__related related"><div class="wrapper"><h2 class="h5 related__title">You should also read:</h2><article class="related__item"><div class="feed__meta"><time datetime="2022-11-08T18:48" class="feed__date">November 8, 2022</time></div><h3 class="h1"><a href="https://blog.chipjohnson.net/an-obvious-thing-about-the-cloud.html">An Obvious Thing About the Cloud</a></h3></article></div></div></main><footer class="footer"><div class="footer__copyright"><p>Copyright Chip Johnson</p></div><button onclick="backToTopFunction()" id="backToTop" class="footer__bttop" aria-label="Back to top" title="Back to top"><svg><use xlink:href="https://blog.chipjohnson.net/assets/svg/svg-map.svg#toparrow"/></svg></button></footer></div><script defer="defer" src="https://blog.chipjohnson.net/assets/js/scripts.min.js?v=f47c11534595205f20935f0db2a62a85"></script><script>window.publiiThemeMenuConfig={mobileMenuMode:'sidebar',animationSpeed:300,submenuWidth: 'auto',doubleClickTime:500,mobileMenuExpandableSubmenus:true,relatedContainerForOverlayMenuSelector:'.top'};</script><script>var images = document.querySelectorAll('img[loading]');

        for (var i = 0; i < images.length; i++) {
            if (images[i].complete) {
                images[i].classList.add('is-loaded');
            } else {
                images[i].addEventListener('load', function () {
                    this.classList.add('is-loaded');
                }, false);
            }
        }</script></body></html>